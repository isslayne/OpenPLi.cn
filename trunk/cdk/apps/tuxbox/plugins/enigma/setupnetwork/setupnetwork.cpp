/***************************************************************************
 *   Copyright (C) 2005 by PLi                                             *
 *   peter@dreamvcr.com                                                    *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <types.h>

#include <iostream>
#include <sstream>
#include <cstdlib>

#include <econfig.h>

#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "enigma_mount.h"

using namespace std;

void unpack(unsigned int l, int *t);
void configureNetwork();
void doMounts();

int main(int argc, char *argv[])
{
	cout << "PLi 2005-2006\nConfigures the network as defined in /var/tuxbox/config/enigma/config\nMount all mountpoint defined in /var/tuxbox/config/enigma/mount.conf\n\n";

	configureNetwork();

	doMounts();
	
	cout << "Exiting" << std::endl;

	return EXIT_SUCCESS;
}

void unpack(unsigned int l, int *t)
{
	for (int i=0; i<4; i++)
		*t++=(l>>((3-i)*8))&0xFF;
}

void configureNetwork()
{
	__u32 sip=0, snetmask=0, sdns=0, sgateway=0;
	int ip[4], netmask[4], dns[4], gateway[4];
	int sdosetup=1, maxmtu=0, useDHCP=1;

	eConfig  oConfig;

	oConfig.getKey("/elitedvb/network/ip", sip);
	oConfig.getKey("/elitedvb/network/netmask", snetmask);
	oConfig.getKey("/elitedvb/network/dns", sdns);
	oConfig.getKey("/elitedvb/network/gateway", sgateway);
	oConfig.getKey("/elitedvb/network/dosetup", sdosetup);
	oConfig.getKey("/elitedvb/network/maxmtu", maxmtu);
	oConfig.getKey("/elitedvb/network/usedhcp", useDHCP);

	unpack(sip, ip);
	unpack(snetmask, netmask);
	unpack(sdns, dns);
	unpack(sgateway, gateway);

	system("killall -9 udhcpc");

	if ( useDHCP )
	{
		FILE *file = fopen("/etc/hostname", "r");
		std::stringstream cmd(std::stringstream::in | std::stringstream::out);
		if (!file)
			printf("couldn't get hostname.. /etc/hostname not exist\n");
		else
		{
			char buf[256];
			struct stat s;
			int len;

			fgets(buf, sizeof(buf), file);
			len = strlen(buf) - 1;
			
			// Remove trailing new line character
			if((buf[len] == '\n') || buf[len] == '\r')
			{
				buf[len] = 0;
			}
			
			fclose(file);
			cmd.str("");
			if ( !stat("/var/share/udhcpc/default.script", &s) )
			{
				cmd << "/bin/udhcpc --hostname=" << buf << " --background --script=/var/share/udhcpc/default.script";
			}
			else
			{
				cmd << "/bin/udhcpc --hostname=" << buf <<  " --background --script=/share/udhcpc/default.script";
			}
			// printf("Going to call : %s\n", cmd.str().c_str());
			if (system(cmd.str().c_str()) >> 8)
			{
				printf("%s failed\n", cmd.str().c_str());
			}
		}
	}
	else
	{
		FILE *f=fopen("/etc/resolv.conf", "wt");
		if (!f)
			printf("couldn't write resolv.conf\n");
		else
		{
			fprintf(f, "# Generated by enigma\nnameserver %d.%d.%d.%d\n", dns[0], dns[1], dns[2], dns[3]);
			fclose(f);
		}
		std::stringstream strIfconfig(std::stringstream::in | std::stringstream::out);
		// Clear the string
		strIfconfig.str("");
		strIfconfig << "/sbin/ifconfig eth0 " << ip[0] << "." << ip[1] << "." << ip[2] << "." << ip[3] << " up netmask " << netmask[0] << "." << netmask[1] << "." << netmask[2] << "." << netmask[3];
		printf("Setting eth0 to use : %d.%d.%d.%d\n", ip[0], ip[1], ip[2], ip[3]);
//		buffer.sprintf("/sbin/ifconfig eth0 %d.%d.%d.%d up netmask %d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3], netmask[0], netmask[1], netmask[2], netmask[3]);
		if (system(strIfconfig.str().c_str())>>8)
			printf("'%s' failed.\n", strIfconfig.str().c_str());
		else
		{
			system("/sbin/route del default 2> /dev/null");
			std::stringstream strRoute(std::stringstream::in | std::stringstream::out);
			strRoute.str("");
			strRoute << "/sbin/route add default gw " << gateway[0] << "." << gateway[1] << "." << gateway[2] << "." << gateway[3];
			//buffer.sprintf("/sbin/route add default gw %d.%d.%d.%d", gateway[0], gateway[1], gateway[2], gateway[3]);
			printf ("Adding route : %s\n", strRoute.str().c_str());
			if (system(strRoute.str().c_str())>>8)
				printf("'%s' failed\n", strRoute.str().c_str());
			if (maxmtu != 0)
			{
				std::stringstream strSetMTU(std::stringstream::in | std::stringstream::out);
				strSetMTU.str("");
				strSetMTU << "/sbin/ifconfig eth0 mtu " << maxmtu;
				printf("setting MAXMTU to %d\n", maxmtu);
				if (system(strSetMTU.str().c_str())>>8)
					printf("'%s' failed\n", strSetMTU.str().c_str());
			}
			//printf("[eDVB] use IP: %d.%d.%d.%d, Netmask: %d.%d.%d.%d, gateway %d.%d.%d.%d, DNS: %d.%d.%d.%d\n",
//				ip[0], ip[1],  ip[2], ip[3],
				//netmask[0], netmask[1],  netmask[2], netmask[3],
				//gateway[0], gateway[1], gateway[2], gateway[3],
				//dns[0], dns[1], dns[2], dns[3]);
		}
	}
}


void doMounts()
{
	eNetworkMountMgr *mountMgr = eNetworkMountMgr::getInstance();
	mountMgr->automountMountPoints();
#if 0
	if (mountMgr->slowAutomounts())
	{
		cout << "Sleep for 4s to give all mountings time to complete" << std::endl; 	 
		usleep(4000000); 	 
	}
#endif
	while (::wait(NULL) >= 0); // wait for all children to finish
	delete mountMgr;
}
